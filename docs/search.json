[
  {
    "objectID": "pyattimo.html",
    "href": "pyattimo.html",
    "title": "PyAttimo: scalable time series motifs mining with Python",
    "section": "",
    "text": "This document showcases the usage of the pyattimo Python package for time series motif discovery, on a rather standard laptop. Most notably, the pyattimo allows to enumerate the motifs one at a time, investing only the computation needed to return the next motif."
  },
  {
    "objectID": "pyattimo.html#setting-things-up",
    "href": "pyattimo.html#setting-things-up",
    "title": "PyAttimo: scalable time series motifs mining with Python",
    "section": "Setting things up",
    "text": "Setting things up\nFirst and foremost, let’s import the pyattimo package.\n\nimport pyattimo\n\nThen, let’s load a dataset from the ones shipped with the python package. On the first run it will be downloaded on your machine from this Figshare. In this example, we are just loading the first million points from the dataset\n\nts = pyattimo.load_dataset(\"ecg\", prefix=1000000)\n\nThe time series looks like the following.\n\n\n\n\n\n\n\n\n\nThe above display looks a bit crowded, but if we focus on the first 10000 points, we can more clearly see the structure."
  },
  {
    "objectID": "pyattimo.html#looking-for-motifs-interactively",
    "href": "pyattimo.html#looking-for-motifs-interactively",
    "title": "PyAttimo: scalable time series motifs mining with Python",
    "section": "Looking for motifs, interactively",
    "text": "Looking for motifs, interactively\nThe pyattimo package provides a rather simple iterator interface:\n\nyou first construct an instance of the MotifsIterator object, specifying the time series, the motif length, and other parameters;\nthen you repeatedly call next on this object to iterat through it\n\nConstructing the iterator requires a time proportional to the time series length. On my dual core machine, this is about 7.8 seconds for our example time series of length 1000000.\n\n%time motifs = pyattimo.MotifsIterator(ts, w=1000, max_k=100)\n\nCPU times: user 13 s, sys: 303 ms, total: 13.3 s\nWall time: 10 s\n\n\nOnce the index is built, we can ask for the first motif. The time required for this operation depends on how distances between subsequences are distributed, rather than by how long the time series is.\n\n%time m = next(motifs)\n\nCPU times: user 17.9 s, sys: 340 ms, total: 18.2 s\nWall time: 12.7 s\n\n\nThe returned pyattimo.Motif object allows to retrieve the starting indices of the subsequences composing the motif, along with the z-normalized Euclidean distance between the two subsequences.\n\nprint(\"Index of first subsequence\", m.a)\nprint(\"Index of second subsequence\", m.b)\nprint(\"z-normalized Euclidean distance\", m.distance)\n\nIndex of first subsequence 723776\nIndex of second subsequence 796052\nz-normalized Euclidean distance 0.4335137534580184\n\n\nFurthermore, you can access the data of the subsequences themselves:\n\nprint(m.values_a())\n\n[-0.734, -0.734, -0.734, -0.734, -1.002, -1.002, -1.002, -1.002, -1.22, -1.22, -1.22, -1.22, -1.376, -1.376, -1.376, -1.376, -1.482, -1.482, -1.482, -1.482, -1.476, -1.476, -1.476, -1.476, -1.351, -1.351, -1.351, -1.351, -1.218, -1.218, -1.218, -1.218, -1.066, -1.066, -1.066, -1.066, -0.879, -0.879, -0.879, -0.879, -0.642, -0.642, -0.642, -0.642, -0.376, -0.376, -0.376, -0.376, -0.192, -0.192, -0.192, -0.192, -0.103, -0.103, -0.103, -0.103, -0.066, -0.066, -0.066, -0.066, -0.044, -0.044, -0.044, -0.044, -0.028, -0.028, -0.028, -0.028, -0.01, -0.01, -0.01, -0.01, 0.001, 0.001, 0.001, 0.001, 0.009, 0.009, 0.009, 0.009, 0.016, 0.016, 0.016, 0.016, 0.024, 0.024, 0.024, 0.024, 0.031, 0.031, 0.031, 0.031, 0.038, 0.038, 0.038, 0.038, 0.044, 0.044, 0.044, 0.044, 0.048, 0.048, 0.048, 0.048, 0.051, 0.051, 0.051, 0.051, 0.054, 0.054, 0.054, 0.054, 0.057, 0.057, 0.057, 0.057, 0.06, 0.06, 0.06, 0.06, 0.061, 0.061, 0.061, 0.061, 0.065, 0.065, 0.065, 0.065, 0.066, 0.066, 0.066, 0.066, 0.068, 0.068, 0.068, 0.068, 0.07, 0.07, 0.07, 0.07, 0.068, 0.068, 0.068, 0.068, 0.068, 0.068, 0.068, 0.068, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.068, 0.068, 0.068, 0.068, 0.067, 0.067, 0.067, 0.067, 0.068, 0.068, 0.068, 0.068, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.068, 0.068, 0.068, 0.068, 0.068, 0.068, 0.068, 0.068, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.068, 0.068, 0.068, 0.068, 0.067, 0.067, 0.067, 0.067, 0.07, 0.07, 0.07, 0.07, 0.067, 0.067, 0.067, 0.067, 0.066, 0.066, 0.066, 0.066, 0.066, 0.066, 0.066, 0.066, 0.068, 0.068, 0.068, 0.068, 0.068, 0.068, 0.068, 0.068, 0.066, 0.066, 0.066, 0.066, 0.067, 0.067, 0.067, 0.067, 0.068, 0.068, 0.068, 0.068, 0.068, 0.068, 0.068, 0.068, 0.068, 0.068, 0.068, 0.068, 0.067, 0.067, 0.067, 0.067, 0.068, 0.068, 0.068, 0.068, 0.07, 0.07, 0.07, 0.07, 0.068, 0.068, 0.068, 0.068, 0.067, 0.067, 0.067, 0.067, 0.068, 0.068, 0.068, 0.068, 0.068, 0.068, 0.068, 0.068, 0.068, 0.068, 0.068, 0.068, 0.067, 0.067, 0.067, 0.067, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.068, 0.068, 0.068, 0.068, 0.067, 0.067, 0.067, 0.067, 0.068, 0.068, 0.068, 0.068, 0.067, 0.067, 0.067, 0.067, 0.067, 0.067, 0.067, 0.067, 0.067, 0.067, 0.067, 0.067, 0.066, 0.066, 0.066, 0.066, 0.068, 0.068, 0.068, 0.068, 0.067, 0.067, 0.067, 0.067, 0.067, 0.067, 0.067, 0.067, 0.068, 0.068, 0.068, 0.068, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.071, 0.071, 0.071, 0.071, 0.07, 0.07, 0.07, 0.07, 0.071, 0.071, 0.071, 0.071, 0.07, 0.07, 0.07, 0.07, 0.071, 0.071, 0.071, 0.071, 0.068, 0.068, 0.068, 0.068, 0.066, 0.066, 0.066, 0.066, 0.065, 0.065, 0.065, 0.065, 0.063, 0.063, 0.063, 0.063, 0.061, 0.061, 0.061, 0.061, 0.06, 0.06, 0.06, 0.06, 0.057, 0.057, 0.057, 0.057, 0.055, 0.055, 0.055, 0.055, 0.055, 0.055, 0.055, 0.055, 0.052, 0.052, 0.052, 0.052, 0.05, 0.05, 0.05, 0.05, 0.049, 0.049, 0.049, 0.049, 0.046, 0.046, 0.046, 0.046, 0.043, 0.043, 0.043, 0.043, 0.039, 0.039, 0.039, 0.039, 0.037, 0.037, 0.037, 0.037, 0.033, 0.033, 0.033, 0.033, 0.028, 0.028, 0.028, 0.028, 0.023, 0.023, 0.023, 0.023, 0.02, 0.02, 0.02, 0.02, 0.016, 0.016, 0.016, 0.016, 0.01, 0.01, 0.01, 0.01, 0.004, 0.004, 0.004, 0.004, -0.001, -0.001, -0.001, -0.001, -0.006, -0.006, -0.006, -0.006, -0.011, -0.011, -0.011, -0.011, -0.016, -0.016, -0.016, -0.016, -0.022, -0.022, -0.022, -0.022, -0.021, -0.021, -0.021, -0.021, -0.024, -0.024, -0.024, -0.024, -0.023, -0.023, -0.023, -0.023, -0.023, -0.023, -0.023, -0.023, -0.023, -0.023, -0.023, -0.023, -0.02, -0.02, -0.02, -0.02, -0.018, -0.018, -0.018, -0.018, -0.017, -0.017, -0.017, -0.017, -0.013, -0.013, -0.013, -0.013, -0.011, -0.011, -0.011, -0.011, -0.007, -0.007, -0.007, -0.007, -0.006, -0.006, -0.006, -0.006, -0.006, -0.006, -0.006, -0.006, -0.006, -0.006, -0.006, -0.006, -0.004, -0.004, -0.004, -0.004, -0.002, -0.002, -0.002, -0.002, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.004, 0.004, 0.004, 0.004, 0.005, 0.005, 0.005, 0.005, 0.007, 0.007, 0.007, 0.007, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.01, 0.01, 0.01, 0.01, 0.012, 0.012, 0.012, 0.012, 0.012, 0.012, 0.012, 0.012, 0.012, 0.012, 0.012, 0.012, 0.012, 0.012, 0.012, 0.012, 0.012, 0.012, 0.012, 0.012, 0.012, 0.012, 0.012, 0.012, 0.01, 0.01, 0.01, 0.01, 0.011, 0.011, 0.011, 0.011, 0.012, 0.012, 0.012, 0.012, 0.011, 0.011, 0.011, 0.011, 0.012, 0.012, 0.012, 0.012, 0.012, 0.012, 0.012, 0.012, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.012, 0.012, 0.012, 0.012, 0.015, 0.015, 0.015, 0.015, 0.012, 0.012, 0.012, 0.012, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.012, 0.012, 0.012, 0.012, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.012, 0.012, 0.012, 0.012, 0.012, 0.012, 0.012, 0.012, 0.011, 0.011, 0.011, 0.011, 0.011, 0.011, 0.011, 0.011, 0.011, 0.011, 0.011, 0.011, 0.011, 0.011, 0.011, 0.011, 0.01, 0.01, 0.01, 0.01, 0.011, 0.011, 0.011, 0.011, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.012, 0.012, 0.012, 0.012, 0.011, 0.011, 0.011, 0.011, 0.011, 0.011, 0.011, 0.011, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.011, 0.011, 0.011, 0.011, 0.012, 0.012, 0.012, 0.012, 0.012, 0.012, 0.012, 0.012, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.011, 0.011, 0.011, 0.011, 0.01, 0.01, 0.01, 0.01, 0.009, 0.009, 0.009, 0.009, 0.007, 0.007, 0.007, 0.007, 0.007, 0.007, 0.007, 0.007, 0.004, 0.004, 0.004, 0.004, 0.005, 0.005, 0.005, 0.005, 0.006, 0.006, 0.006, 0.006, 0.006, 0.006, 0.006, 0.006, 0.005, 0.005, 0.005, 0.005, 0.004, 0.004, 0.004, 0.004, 0.004, 0.004, 0.004, 0.004, 0.004, 0.004, 0.004, 0.004, 0.004, 0.004, 0.004, 0.004, 0.006, 0.006, 0.006, 0.006, 0.006, 0.006, 0.006, 0.006, 0.004, 0.004, 0.004, 0.004, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.004, 0.004, 0.004, 0.004, 0.002, 0.002, 0.002, 0.002, 0.001, 0.001, 0.001, 0.001, 0.002, 0.002, 0.002, 0.002, 0.004, 0.004, 0.004, 0.004, 0.001, 0.001, 0.001, 0.001, 0.002, 0.002, 0.002, 0.002, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, -0.001, -0.001, -0.001, -0.001, -0.001, -0.001, -0.001, -0.001, -0.002, -0.002, -0.002, -0.002, -0.002, -0.002, -0.002, -0.002, -0.002, -0.002, -0.002, -0.002, -0.001, -0.001, -0.001, -0.001, -0.002, -0.002, -0.002, -0.002, -0.002, -0.002, -0.002, -0.002, -0.002, -0.002, -0.002, -0.002, -0.002, -0.002, -0.002, -0.002, -0.002, -0.002, -0.002, -0.002, -0.004, -0.004, -0.004, -0.004, -0.004, -0.004, -0.004, -0.004, -0.004, -0.004, -0.004, -0.004, -0.004, -0.004, -0.004, -0.004, -0.004, -0.004, -0.004, -0.004]\n\n\n\nprint(m.values_b())\n\n[-0.707, -0.707, -0.707, -0.707, -0.972, -0.972, -0.972, -0.972, -1.194, -1.194, -1.194, -1.194, -1.345, -1.345, -1.345, -1.345, -1.448, -1.448, -1.448, -1.448, -1.435, -1.435, -1.435, -1.435, -1.314, -1.314, -1.314, -1.314, -1.182, -1.182, -1.182, -1.182, -1.039, -1.039, -1.039, -1.039, -0.855, -0.855, -0.855, -0.855, -0.623, -0.623, -0.623, -0.623, -0.354, -0.354, -0.354, -0.354, -0.175, -0.175, -0.175, -0.175, -0.088, -0.088, -0.088, -0.088, -0.052, -0.052, -0.052, -0.052, -0.033, -0.033, -0.033, -0.033, -0.018, -0.018, -0.018, -0.018, -0.001, -0.001, -0.001, -0.001, 0.01, 0.01, 0.01, 0.01, 0.016, 0.016, 0.016, 0.016, 0.024, 0.024, 0.024, 0.024, 0.032, 0.032, 0.032, 0.032, 0.038, 0.038, 0.038, 0.038, 0.043, 0.043, 0.043, 0.043, 0.049, 0.049, 0.049, 0.049, 0.054, 0.054, 0.054, 0.054, 0.06, 0.06, 0.06, 0.06, 0.062, 0.062, 0.062, 0.062, 0.063, 0.063, 0.063, 0.063, 0.067, 0.067, 0.067, 0.067, 0.071, 0.071, 0.071, 0.071, 0.072, 0.072, 0.072, 0.072, 0.071, 0.071, 0.071, 0.071, 0.072, 0.072, 0.072, 0.072, 0.073, 0.073, 0.073, 0.073, 0.072, 0.072, 0.072, 0.072, 0.072, 0.072, 0.072, 0.072, 0.074, 0.074, 0.074, 0.074, 0.074, 0.074, 0.074, 0.074, 0.074, 0.074, 0.074, 0.074, 0.074, 0.074, 0.074, 0.074, 0.074, 0.074, 0.074, 0.074, 0.076, 0.076, 0.076, 0.076, 0.073, 0.073, 0.073, 0.073, 0.072, 0.072, 0.072, 0.072, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.071, 0.071, 0.071, 0.071, 0.068, 0.068, 0.068, 0.068, 0.07, 0.07, 0.07, 0.07, 0.068, 0.068, 0.068, 0.068, 0.068, 0.068, 0.068, 0.068, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.07, 0.068, 0.068, 0.068, 0.068, 0.068, 0.068, 0.068, 0.068, 0.072, 0.072, 0.072, 0.072, 0.074, 0.074, 0.074, 0.074, 0.073, 0.073, 0.073, 0.073, 0.073, 0.073, 0.073, 0.073, 0.074, 0.074, 0.074, 0.074, 0.073, 0.073, 0.073, 0.073, 0.076, 0.076, 0.076, 0.076, 0.074, 0.074, 0.074, 0.074, 0.074, 0.074, 0.074, 0.074, 0.078, 0.078, 0.078, 0.078, 0.076, 0.076, 0.076, 0.076, 0.074, 0.074, 0.074, 0.074, 0.074, 0.074, 0.074, 0.074, 0.074, 0.074, 0.074, 0.074, 0.074, 0.074, 0.074, 0.074, 0.073, 0.073, 0.073, 0.073, 0.072, 0.072, 0.072, 0.072, 0.076, 0.076, 0.076, 0.076, 0.074, 0.074, 0.074, 0.074, 0.076, 0.076, 0.076, 0.076, 0.073, 0.073, 0.073, 0.073, 0.076, 0.076, 0.076, 0.076, 0.077, 0.077, 0.077, 0.077, 0.078, 0.078, 0.078, 0.078, 0.077, 0.077, 0.077, 0.077, 0.078, 0.078, 0.078, 0.078, 0.079, 0.079, 0.079, 0.079, 0.078, 0.078, 0.078, 0.078, 0.078, 0.078, 0.078, 0.078, 0.081, 0.081, 0.081, 0.081, 0.082, 0.082, 0.082, 0.082, 0.082, 0.082, 0.082, 0.082, 0.082, 0.082, 0.082, 0.082, 0.082, 0.082, 0.082, 0.082, 0.081, 0.081, 0.081, 0.081, 0.078, 0.078, 0.078, 0.078, 0.078, 0.078, 0.078, 0.078, 0.077, 0.077, 0.077, 0.077, 0.077, 0.077, 0.077, 0.077, 0.077, 0.077, 0.077, 0.077, 0.074, 0.074, 0.074, 0.074, 0.073, 0.073, 0.073, 0.073, 0.073, 0.073, 0.073, 0.073, 0.07, 0.07, 0.07, 0.07, 0.068, 0.068, 0.068, 0.068, 0.066, 0.066, 0.066, 0.066, 0.065, 0.065, 0.065, 0.065, 0.065, 0.065, 0.065, 0.065, 0.062, 0.062, 0.062, 0.062, 0.059, 0.059, 0.059, 0.059, 0.057, 0.057, 0.057, 0.057, 0.055, 0.055, 0.055, 0.055, 0.052, 0.052, 0.052, 0.052, 0.048, 0.048, 0.048, 0.048, 0.044, 0.044, 0.044, 0.044, 0.04, 0.04, 0.04, 0.04, 0.033, 0.033, 0.033, 0.033, 0.027, 0.027, 0.027, 0.027, 0.023, 0.023, 0.023, 0.023, 0.017, 0.017, 0.017, 0.017, 0.011, 0.011, 0.011, 0.011, 0.005, 0.005, 0.005, 0.005, 0.001, 0.001, 0.001, 0.001, -0.004, -0.004, -0.004, -0.004, -0.007, -0.007, -0.007, -0.007, -0.012, -0.012, -0.012, -0.012, -0.016, -0.016, -0.016, -0.016, -0.015, -0.015, -0.015, -0.015, -0.017, -0.017, -0.017, -0.017, -0.017, -0.017, -0.017, -0.017, -0.016, -0.016, -0.016, -0.016, -0.013, -0.013, -0.013, -0.013, -0.011, -0.011, -0.011, -0.011, -0.009, -0.009, -0.009, -0.009, -0.006, -0.006, -0.006, -0.006, -0.002, -0.002, -0.002, -0.002, -0.002, -0.002, -0.002, -0.002, 0.004, 0.004, 0.004, 0.004, 0.006, 0.006, 0.006, 0.006, 0.007, 0.007, 0.007, 0.007, 0.009, 0.009, 0.009, 0.009, 0.012, 0.012, 0.012, 0.012, 0.016, 0.016, 0.016, 0.016, 0.016, 0.016, 0.016, 0.016, 0.018, 0.018, 0.018, 0.018, 0.02, 0.02, 0.02, 0.02, 0.021, 0.021, 0.021, 0.021, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.022, 0.022, 0.022, 0.022, 0.023, 0.023, 0.023, 0.023, 0.024, 0.024, 0.024, 0.024, 0.024, 0.024, 0.024, 0.024, 0.024, 0.024, 0.024, 0.024, 0.026, 0.026, 0.026, 0.026, 0.026, 0.026, 0.026, 0.026, 0.024, 0.024, 0.024, 0.024, 0.026, 0.026, 0.026, 0.026, 0.027, 0.027, 0.027, 0.027, 0.027, 0.027, 0.027, 0.027, 0.026, 0.026, 0.026, 0.026, 0.027, 0.027, 0.027, 0.027, 0.027, 0.027, 0.027, 0.027, 0.024, 0.024, 0.024, 0.024, 0.023, 0.023, 0.023, 0.023, 0.026, 0.026, 0.026, 0.026, 0.028, 0.028, 0.028, 0.028, 0.026, 0.026, 0.026, 0.026, 0.026, 0.026, 0.026, 0.026, 0.023, 0.023, 0.023, 0.023, 0.024, 0.024, 0.024, 0.024, 0.023, 0.023, 0.023, 0.023, 0.023, 0.023, 0.023, 0.023, 0.024, 0.024, 0.024, 0.024, 0.026, 0.026, 0.026, 0.026, 0.023, 0.023, 0.023, 0.023, 0.023, 0.023, 0.023, 0.023, 0.021, 0.021, 0.021, 0.021, 0.023, 0.023, 0.023, 0.023, 0.023, 0.023, 0.023, 0.023, 0.022, 0.022, 0.022, 0.022, 0.021, 0.021, 0.021, 0.021, 0.023, 0.023, 0.023, 0.023, 0.023, 0.023, 0.023, 0.023, 0.023, 0.023, 0.023, 0.023, 0.022, 0.022, 0.022, 0.022, 0.022, 0.022, 0.022, 0.022, 0.023, 0.023, 0.023, 0.023, 0.023, 0.023, 0.023, 0.023, 0.022, 0.022, 0.022, 0.022, 0.023, 0.023, 0.023, 0.023, 0.024, 0.024, 0.024, 0.024, 0.023, 0.023, 0.023, 0.023, 0.022, 0.022, 0.022, 0.022, 0.021, 0.021, 0.021, 0.021, 0.022, 0.022, 0.022, 0.022, 0.021, 0.021, 0.021, 0.021, 0.021, 0.021, 0.021, 0.021, 0.018, 0.018, 0.018, 0.018, 0.021, 0.021, 0.021, 0.021, 0.021, 0.021, 0.021, 0.021, 0.021, 0.021, 0.021, 0.021, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.02, 0.017, 0.017, 0.017, 0.017, 0.018, 0.018, 0.018, 0.018, 0.018, 0.018, 0.018, 0.018, 0.016, 0.016, 0.016, 0.016, 0.016, 0.016, 0.016, 0.016, 0.016, 0.016, 0.016, 0.016, 0.013, 0.013, 0.013, 0.013, 0.012, 0.012, 0.012, 0.012, 0.013, 0.013, 0.013, 0.013, 0.012, 0.012, 0.012, 0.012, 0.015, 0.015, 0.015, 0.015, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.012, 0.012, 0.012, 0.012, 0.011, 0.011, 0.011, 0.011, 0.012, 0.012, 0.012, 0.012, 0.012, 0.012, 0.012, 0.012, 0.015, 0.015, 0.015, 0.015, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.011, 0.011, 0.011, 0.011, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.015, 0.015, 0.015, 0.015, 0.015, 0.015, 0.015, 0.015, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.012, 0.012, 0.012, 0.012, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.012, 0.012, 0.012, 0.012, 0.011, 0.011, 0.011, 0.011, 0.011, 0.011, 0.011, 0.011, 0.011, 0.011, 0.011, 0.011, 0.011, 0.011, 0.011, 0.011, 0.009, 0.009, 0.009, 0.009, 0.01, 0.01, 0.01, 0.01, 0.009, 0.009, 0.009, 0.009, 0.01, 0.01, 0.01, 0.01, 0.009, 0.009, 0.009, 0.009, 0.01, 0.01, 0.01, 0.01, 0.012, 0.012, 0.012, 0.012, 0.011, 0.011, 0.011, 0.011]\n\n\nThe returned pyattimo.Motif has a plot method that shows the motif subsequences, their z-normalized versions, and the positions of the motif in the original time series.\nFinally, and perhaps most importantly for the interactive exploration of time series, the Motif object allows you to plot it.\n\nm.plot()\n\n\n\n\nPlot of the top motif in the dataset, with the positions in the original series highlighted (top plot), the plot of the original subsequences overlaid on top of each other (middle), and the plot of the overlay of their z-normalized version.\n\n\n\n\nGiven that the MotifsIterator object is, well, an iterator, you can easily ask for the next motif:\n\n%time m = next(motifs)\nm.plot()\n\nCPU times: user 7 µs, sys: 1 µs, total: 8 µs\nWall time: 11 µs\n\n\n\n\n\nThe second motif in the dataset.\n\n\n\n\nNotice that the time to discover this second motif is much shorter than the time that was required to discover the first one: microseconds instead of seconds. This is a property of the underlying algorithm: for further details we invite you to read the full paper.\nThis explorative process of looking at can be iterated as long as needed, interactively. The motifs are returned by increasing values of distance of their subsequences: as soon as we find a motif whose subsequences are so far away as to no longer be interesting, we can stop the process."
  },
  {
    "objectID": "pyattimo.html#comparison-with-stumpy-and-pyscamp",
    "href": "pyattimo.html#comparison-with-stumpy-and-pyscamp",
    "title": "PyAttimo: scalable time series motifs mining with Python",
    "section": "Comparison with stumpy and pyscamp",
    "text": "Comparison with stumpy and pyscamp\nSo far, we have seen how pyattimo allows to interactively explore motifs. But how does it compare with the state of the art in motif discovery? There is a rich line of work investigating the efficient use of the matrix profile, a data structure that for each subsequence of the input time series holds information about its most similar subsequence.\nIn particular, the stumpy Python package implements a Numba JIT-compiled version of the algorithm presented by Zhu et al. (2016), with a very convenient user interface.\nA very efficient C++ Matrix Profile implementation (with GPU support) is provided by scamp, implementing ideas presented in the paper by Zimmerman et al. (2019). scamp comes with a Python interface, namely pyscamp.\nBoth stumpy and pyscamp support GPU execution, but this notebook has been rendered on a system somewhat computationally limited1. In particular, this system does not support CUDA. Therefore, we will focus on the CPU functionality provided by both packages, and compare attimo with both.1 A 2017 MacBook Pro with a 2.3 GHz Intel Core i5 dual core processor, with 8GB of RAM memory.\nWe consider the ECG dataset we already introduced above, with 1,000,000 data points. As a benchmark, we will measure the running time of both stumpy, pyscamp, and attimo on prefixes of increasing size of the time series. For attimo, we extract from the iterator only the first motif.\nBeware that stumpy and pyscamp compute the full matrix profile, which contains a lot more information than just the top motif. The point of this (rather unscientific) benchmark is to get a sense of the gains we can make if we focus on just finding the top motif.Later we shall see how many motifs we can find before the fastest of the baselines completes.\nThe plot below reports the results of this experiment (you can expand the code to see how the experiments have been run).\n\n\nCode\nimport sqlite3\nimport time \nimport stumpy\nimport pyscamp\nimport pandas as pd\nimport seaborn as sns\nimport numpy as np\n\nw = 1000\n\n# force numba precompilation\nstumpy.stump(ts[:2*w], m=w)\n\n# We persist results in a sqlite database, so to avoid rerunning experiments unnecessarily\ndef already_run(db, algorithm, prefix):\n    return db.execute(\n        \"SELECT * FROM experiments WHERE algorithm = ? AND prefix = ?\", \n        [algorithm, prefix]).fetchone() is not None\n\nwith sqlite3.connect(\".quarto/experiments.db\") as db:\n    db.execute(\"CREATE TABLE IF NOT EXISTS experiments (algorithm TEXT, prefix INT, time_s REAL)\")\n\n    prefixes = [10000, 25000, 30000, 50000, 75000, 100000, 250000, 500000, 1000000]\n\n    timeout = 20\n\n    for prefix in prefixes:\n        # the prefix on which to benchmark\n        data = ts[:prefix]\n\n        if prefix <= 250000 and not already_run(db, \"stumpy\", prefix):\n            start = time.time()\n            stumpy.stump(data, m=w)\n            end = time.time()\n            db.execute(\"INSERT INTO experiments VALUES (?, ?, ?)\", [\"stumpy\", prefix, end - start])\n\n        if prefix <= 500000 and not already_run(db, \"pyscamp\", prefix):\n            start = time.time()\n            pyscamp.selfjoin(data, w)\n            end = time.time()\n            db.execute(\"INSERT INTO experiments VALUES (?, ?, ?)\", [\"pyscamp\", prefix, end - start])\n\n        if not already_run(db, \"attimo\", prefix):\n            start = time.time()\n            motifs_iter = pyattimo.MotifsIterator(data, w=w, max_k=1, repetitions=50, delta=0.01)\n            next(motifs_iter)\n            end = time.time()\n            db.execute(\"INSERT INTO experiments VALUES (?, ?, ?)\", [\"attimo\", prefix, end - start])\n\n    results = pd.read_sql(\"SELECT prefix, algorithm, time_s FROM experiments ORDER BY prefix, algorithm\", db)\n\ncolors = sns.color_palette()\npalette = {\n    \"attimo\": colors[0],\n    \"pyscamp\": colors[1],\n    \"stumpy\": colors[2]\n}\nax = sns.lineplot(\n    data = results,\n    x = \"prefix\",\n    y = \"time_s\",\n    hue = \"algorithm\",\n    palette = palette\n)\n\n# Polynomial (2nd degree) regression to fill in times for larger prefixes\nfits = {}\nfor algorithm in [\"pyscamp\"]:\n    fitdat = results[results[\"algorithm\"] == algorithm]\n    fits[algorithm] = np.poly1d(np.polyfit(fitdat[\"prefix\"], fitdat[\"time_s\"], 2))\n    xs = np.linspace(fitdat[\"prefix\"].max(), prefixes[-1])\n    ax.plot(xs, fits[algorithm](xs), '--', color=palette[algorithm])\n\nplt.show()\n\n\n\n\n\nRuntime comparison on time series of different lengths to find the top motif. Dashed lines are for estimated runtimes.\n\n\n\n\nThe expected behavior of both pyscamp and stumpy is to require time \\(O(n^2)\\), where \\(n\\) is the length of the time series. Indeed, from the plot we can infer that this is the actual behavior in this experiment: doubling the time series length quadruples the running time.\nAs for attimo, note that the running time to find the top motif is much shorter: the following table reports the same times (in seconds) that are shown in the above plotEntries reporting - are for timed out runs.\n\n\n\n\n\nprefix\nattimo\npyscamp\nstumpy\n\n\n\n\n10000\n0.20\n0.07\n0.28\n\n\n25000\n0.38\n0.29\n1.90\n\n\n30000\n0.50\n0.38\n2.10\n\n\n50000\n0.74\n0.95\n6.32\n\n\n75000\n4.81\n2.56\n20.76\n\n\n100000\n1.46\n3.88\n40.62\n\n\n250000\n3.47\n26.09\n255.20\n\n\n500000\n5.56\n83.76\n-\n\n\n1000000\n18.84\n-\n-\n\n\n\n\n\nAs said above, both pyscamp and stumpy return the full matrix profile, which contains more information than just the top motif. Indeed, it can be used to retrieve the other motifs (albeit with some caveats). To take into account this, rather than fixing a-priori an arbitrary number of motifs to look for, we fix as a time budget the time employed by the fastest baseline, pyscamp, on one million data points. Given that budget, we traverse the motif iterator provided by attimo until the time budget is exhausted, counting how many motifs we are able to discover. This procedure is implemented by the following snippet.\n\ndef enumerate_with_budget(motifs_iterator, budget):\n    start = time.time()\n    times = []\n    motifs = []\n    cnt = 0\n    elapsed = 0\n    while elapsed <= budget:\n        try:\n            m = next(motifs_iterator)\n            cnt += 1\n            elapsed = time.time() - start \n            times.append(elapsed)\n            motifs.append(m)\n        except StopIteration:\n            return cnt, times, motifs\n    return cnt, times, motifs\n\nThe following code runs the experiment, using as a budged the \\(\\approx 300\\) seconds employed by pyscamp.\n\nimport os\nfname = \".discover.parquet\"\ntime_budget = fits[\"pyscamp\"](len(ts))\nif not os.path.isfile(fname):\n    start = time.time() \n    motifs = pyattimo.MotifsIterator(ts, w=1000, max_k=300, repetitions=50, delta=0.01)\n    end = time.time()\n    index_time = end - start\n    cnt, elapsed_times, motifs_list = enumerate_with_budget(motifs, time_budget - index_time)\n\n    elapsed_times = pd.DataFrame({\n        'elapsed_time_s': elapsed_times,\n        'motif_distance': [m.distance for m in motifs_list],\n        'motif_rank': np.arange(len(elapsed_times))\n    })\n    elapsed_times.to_parquet(fname)\nelse:\n    elapsed_times = pd.read_parquet(fname)\n\nprint(\"Motifs found in {:.2f} seconds: {}\".format(time_budget, elapsed_times.shape[0]))\n\nMotifs found in 297.47 seconds: 243\n\n\nUsing attimo, we can iterate through over 200 motifs before pyscamp is done computing the matrix profile!"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Attimo: fast time series motif mining",
    "section": "",
    "text": "Attimo is a software package for quickly finding motifs in time series. Its name, that is Italian means instant, is an acronym for AdapTive TImeseries MOtifs: in fact, the peculiarity of the algorithm underlying this implementation is that it is adaptive to the data distribution."
  },
  {
    "objectID": "index.html#what-is-a-motif",
    "href": "index.html#what-is-a-motif",
    "title": "Attimo: fast time series motif mining",
    "section": "What is a motif?",
    "text": "What is a motif?\nA time series (i.e. a sequence of time-varying values) can be chunked in several subsequences of a given length \\(w\\). The similarity between two given subsequences of a time series can be measured using several distance measures. A very common choice is the Euclidean distance, along with its variant the z-normalized Euclidean distance.\nIntuitively, a motif is a subsequence in a time series that has at least one similar occurrence in another location of the same time series.\nMore formally, for a fixed subsequence length \\(w\\) and for a given distance function between subsequences of length \\(m\\) of a time series, we can define the top motif as being the pair of subsequences at minimum distance. Since subsequences can overlap, usually overlapping subsequences are ignored1."
  },
  {
    "objectID": "index.html#how-does-this-software-work",
    "href": "index.html#how-does-this-software-work",
    "title": "Attimo: fast time series motif mining",
    "section": "How does this software work?",
    "text": "How does this software work?\nThis software is implemented in the Rust programming language and can be used as a Rust library. For convenience, we provide a Python wrapper providing the full functionality.\nIn particular, you can specify an input time series and the desired window length, and the library will return a lazy iterator of the top motifs:\n\n# Load the library\nimport pyattimo\n# Load an example dataset\nts = pyattimo.load_dataset(\"ecg\", prefix=100000)\n# Build the iterator\nmotifs_iter = pyattimo.MotifsIterator(ts, w=1000, max_k=10)\n# Iterate through the motifs\nfor rank, motif in enumerate(motifs_iter):\n    print(\"Motif {} between {} and {} at distance {:.3}\".format(\n        rank,\n        motif.a,\n        motif.b,\n        motif.distance\n    ))\n\nMotif 0 between 82088 and 89708 at distance 0.814\nMotif 1 between 44164 and 95648 at distance 0.909\n\n\nMotif 2 between 26581 and 93613 at distance 1.07\nMotif 3 between 28272 and 30704 at distance 1.27\nMotif 4 between 84732 and 97912 at distance 1.29\nMotif 5 between 1328 and 17384 at distance 1.32\nMotif 6 between 23572 and 49424 at distance 1.38\nMotif 7 between 33016 and 34264 at distance 1.49\nMotif 8 between 18499 and 96675 at distance 1.58\nMotif 9 between 48287 and 77807 at distance 1.65"
  },
  {
    "objectID": "index.html#how-does-the-algorithm-work",
    "href": "index.html#how-does-the-algorithm-work",
    "title": "Attimo: fast time series motif mining",
    "section": "How does the algorithm work?",
    "text": "How does the algorithm work?\nThe algorithm is based on Locality Sensitive Hashing and takes advantage of the distribution of distances in the dataset.\nThe details are described in the paper Fast and Scalable Mining of Time Series Motifs with Probabilistic Guarantees by Matteo Ceccarello and Johann Gamper, soon to appear in PVLDB 15(13)."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  }
]