[
  {
    "objectID": "pyattimo.html",
    "href": "pyattimo.html",
    "title": "PyAttimo: scalable time series motifs mining with Python",
    "section": "",
    "text": "This document showcases the usage of the pyattimo Python package for time series motif discovery, on a rather standard laptop. Most notably, the pyattimo allows to enumerate the motifs one at a time, investing only the computation needed to return the next motif."
  },
  {
    "objectID": "pyattimo.html#setting-things-up",
    "href": "pyattimo.html#setting-things-up",
    "title": "PyAttimo: scalable time series motifs mining with Python",
    "section": "Setting things up",
    "text": "Setting things up\nFirst and foremost, let’s import the pyattimo package.\n\nimport pyattimo\n\nThen, let’s load a dataset from the ones shipped with the python package. On the first run it will be downloaded on your machine from this Figshare. In this example, we are just loading the first million points from the dataset\n\nts = pyattimo.load_dataset(\"ecg\", prefix=1000000)\n\nThe time series looks like the following.\n\n\n\n\n\n\n\n\n\nThe above display looks a bit crowded, but if we focus on the first 10000 points, we can more clearly see the structure."
  },
  {
    "objectID": "pyattimo.html#looking-for-motifs-interactively",
    "href": "pyattimo.html#looking-for-motifs-interactively",
    "title": "PyAttimo: scalable time series motifs mining with Python",
    "section": "Looking for motifs, interactively",
    "text": "Looking for motifs, interactively\nThe pyattimo package provides a rather simple iterator interface:\n\nyou first construct an instance of the MotifsIterator object, specifying the time series, the motif length, and other parameters;\nthen you repeatedly call next on this object to iterat through it\n\nConstructing the iterator requires a time proportional to the time series length. On my dual core machine, this is about 7.8 seconds for our example time series of length 1000000.\n\n%time motifs = pyattimo.MotifsIterator(ts, w=1000, max_k=100)\n\nCPU times: user 20.6 s, sys: 519 ms, total: 21.1 s\nWall time: 10.4 s\n\n\nOnce the index is built, we can ask for the first motif. The time required for this operation depends on how distances between subsequences are distributed, rather than by how long the time series is.\n\n%time m = next(motifs)\n\nCPU times: user 27.8 s, sys: 512 ms, total: 28.3 s\nWall time: 12.7 s\n\n\nThe returned pyattimo.Motif object allows to retrieve the starting indices of the subsequences composing the motif, along with the z-normalized Euclidean distance between the two subsequences.\n\nprint(\"Index of first subsequence\", m.a)\nprint(\"Index of second subsequence\", m.b)\nprint(\"z-normalized Euclidean distance\", m.distance)\n\nIndex of first subsequence 439120\nIndex of second subsequence 785692\nz-normalized Euclidean distance 0.4495888874706488\n\n\nFurthermore, you can access the data of the subsequences themselves:\n\nprint(m.values_a())\n\n[0.006, 0.006, 0.006, 0.006, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.007, 0.007, 0.007, 0.007, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.01, 0.01, 0.01, 0.01, 0.011, 0.011, 0.011, 0.011, 0.012, 0.012, 0.012, 0.012, 0.011, 0.011, 0.011, 0.011, 0.011, 0.011, 0.011, 0.011, 0.012, 0.012, 0.012, 0.012, 0.01, 0.01, 0.01, 0.01, 0.007, 0.007, 0.007, 0.007, 0.006, 0.006, 0.006, 0.006, 0.006, 0.006, 0.006, 0.006, 0.007, 0.007, 0.007, 0.007, 0.006, 0.006, 0.006, 0.006, 0.006, 0.006, 0.006, 0.006, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.01, 0.01, 0.01, 0.01, 0.012, 0.012, 0.012, 0.012, 0.012, 0.012, 0.012, 0.012, 0.011, 0.011, 0.011, 0.011, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.013, 0.012, 0.012, 0.012, 0.012, 0.011, 0.011, 0.011, 0.011, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.006, 0.006, 0.006, 0.006, 0.007, 0.007, 0.007, 0.007, 0.009, 0.009, 0.009, 0.009, 0.01, 0.01, 0.01, 0.01, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.01, 0.01, 0.01, 0.01, 0.009, 0.009, 0.009, 0.009, 0.006, 0.006, 0.006, 0.006, 0.007, 0.007, 0.007, 0.007, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.007, 0.007, 0.007, 0.007, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.006, 0.006, 0.006, 0.006, 0.006, 0.006, 0.006, 0.006, 0.004, 0.004, 0.004, 0.004, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.005, 0.006, 0.006, 0.006, 0.006, 0.005, 0.005, 0.005, 0.005, 0.006, 0.006, 0.006, 0.006, 0.005, 0.005, 0.005, 0.005, 0.004, 0.004, 0.004, 0.004, 0.002, 0.002, 0.002, 0.002, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.002, 0.002, 0.002, 0.002, 0.001, 0.001, 0.001, 0.001, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, -0.001, -0.001, -0.001, -0.001, -0.001, -0.001, -0.001, -0.001, -0.001, -0.001, -0.001, -0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.002, 0.002, 0.002, 0.002, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, -0.001, -0.001, -0.001, -0.001, -0.001, -0.001, -0.001, -0.001, -0.001, -0.001, -0.001, -0.001, -0.001, -0.001, -0.001, -0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.004, 0.004, 0.004, 0.004, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.002, 0.002, 0.002, 0.002, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.002, 0.002, 0.002, 0.002, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.004, 0.004, 0.004, 0.004, 0.005, 0.005, 0.005, 0.005, 0.004, 0.004, 0.004, 0.004, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.002, 0.001, 0.001, 0.001, 0.001, 0.002, 0.002, 0.002, 0.002, 0.001, 0.001, 0.001, 0.001, 0.004, 0.004, 0.004, 0.004, 0.007, 0.007, 0.007, 0.007, 0.006, 0.006, 0.006, 0.006, 0.006, 0.006, 0.006, 0.006, 0.006, 0.006, 0.006, 0.006, 0.004, 0.004, 0.004, 0.004, 0.006, 0.006, 0.006, 0.006, 0.005, 0.005, 0.005, 0.005, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, 0.001, -0.005, -0.005, -0.005, -0.005, -0.011, -0.011, -0.011, -0.011, -0.016, -0.016, -0.016, -0.016, -0.02, -0.02, -0.02, -0.02, -0.018, -0.018, -0.018, -0.018, -0.021, -0.021, -0.021, -0.021, -0.026, -0.026, -0.026, -0.026, -0.024, -0.024, -0.024, -0.024, -0.024, -0.024, -0.024, -0.024, -0.024, -0.024, -0.024, -0.024, -0.024, -0.024, -0.024, -0.024, -0.022, -0.022, -0.022, -0.022, -0.023, -0.023, -0.023, -0.023, -0.024, -0.024, -0.024, -0.024, -0.023, -0.023, -0.023, -0.023, -0.022, -0.022, -0.022, -0.022, -0.021, -0.021, -0.021, -0.021, -0.02, -0.02, -0.02, -0.02, -0.02, -0.02, -0.02, -0.02, -0.016, -0.016, -0.016, -0.016, -0.01, -0.01, -0.01, -0.01, -0.006, -0.006, -0.006, -0.006, -0.005, -0.005, -0.005, -0.005, -0.006, -0.006, -0.006, -0.006, -0.005, -0.005, -0.005, -0.005, -0.006, -0.006, -0.006, -0.006, -0.007, -0.007, -0.007, -0.007, -0.006, -0.006, -0.006, -0.006, -0.004, -0.004, -0.004, -0.004, -0.004, -0.004, -0.004, -0.004, -0.005, -0.005, -0.005, -0.005, -0.005, -0.005, -0.005, -0.005, -0.005, -0.005, -0.005, -0.005, -0.006, -0.006, -0.006, -0.006, -0.004, -0.004, -0.004, -0.004, -0.005, -0.005, -0.005, -0.005, -0.004, -0.004, -0.004, -0.004, -0.005, -0.005, -0.005, -0.005, -0.006, -0.006, -0.006, -0.006, -0.006, -0.006, -0.006, -0.006, -0.005, -0.005, -0.005, -0.005, -0.005, -0.005, -0.005, -0.005, -0.004, -0.004, -0.004, -0.004, -0.006, -0.006, -0.006, -0.006, -0.006, -0.006, -0.006, -0.006, -0.005, -0.005, -0.005, -0.005, -0.005, -0.005, -0.005, -0.005, -0.004, -0.004, -0.004, -0.004, -0.002, -0.002, -0.002, -0.002, -0.001, -0.001, -0.001, -0.001, 0.004, 0.004, 0.004, 0.004, 0.012, 0.012, 0.012, 0.012, 0.028, 0.028, 0.028, 0.028, 0.05, 0.05, 0.05, 0.05, 0.073, 0.073, 0.073, 0.073, 0.106, 0.106, 0.106, 0.106, 0.123, 0.123, 0.123, 0.123, 0.134, 0.134, 0.134, 0.134, 0.142, 0.142, 0.142, 0.142, 0.138, 0.138, 0.138, 0.138, 0.094, 0.094, 0.094, 0.094, 0.015, 0.015, 0.015, 0.015, -0.148, -0.148, -0.148, -0.148, -0.339, -0.339, -0.339, -0.339, -0.595, -0.595, -0.595, -0.595, -0.895, -0.895, -0.895, -0.895, -1.135, -1.135, -1.135, -1.135, -1.327, -1.327, -1.327, -1.327, -1.478, -1.478, -1.478, -1.478, -1.547, -1.547, -1.547, -1.547, -1.488, -1.488, -1.488, -1.488, -1.343, -1.343, -1.343, -1.343, -1.211, -1.211, -1.211, -1.211, -1.026, -1.026, -1.026, -1.026, -0.823, -0.823, -0.823, -0.823, -0.548, -0.548, -0.548, -0.548, -0.293, -0.293, -0.293, -0.293, -0.155, -0.155, -0.155, -0.155, -0.096, -0.096, -0.096, -0.096, -0.071, -0.071, -0.071, -0.071, -0.052, -0.052, -0.052, -0.052, -0.035, -0.035, -0.035, -0.035, -0.018, -0.018, -0.018, -0.018, -0.012, -0.012, -0.012, -0.012, -0.002, -0.002, -0.002, -0.002, 0.004, 0.004, 0.004, 0.004, 0.01, 0.01, 0.01, 0.01, 0.018, 0.018, 0.018, 0.018, 0.023, 0.023, 0.023, 0.023, 0.027, 0.027, 0.027, 0.027, 0.033, 0.033, 0.033, 0.033, 0.037, 0.037, 0.037, 0.037, 0.04, 0.04, 0.04, 0.04, 0.043, 0.043, 0.043, 0.043, 0.045, 0.045, 0.045, 0.045, 0.048, 0.048, 0.048, 0.048, 0.05, 0.05, 0.05, 0.05, 0.051, 0.051, 0.051, 0.051, 0.055, 0.055, 0.055, 0.055, 0.054, 0.054, 0.054, 0.054, 0.055, 0.055, 0.055, 0.055, 0.055, 0.055, 0.055, 0.055, 0.056, 0.056, 0.056, 0.056, 0.055, 0.055, 0.055, 0.055, 0.056, 0.056, 0.056, 0.056, 0.057, 0.057, 0.057, 0.057, 0.057, 0.057, 0.057, 0.057, 0.055, 0.055, 0.055, 0.055, 0.056, 0.056, 0.056, 0.056, 0.056, 0.056, 0.056, 0.056, 0.057, 0.057, 0.057, 0.057, 0.056, 0.056, 0.056, 0.056, 0.055, 0.055, 0.055, 0.055, 0.056, 0.056, 0.056, 0.056, 0.056, 0.056, 0.056, 0.056, 0.059, 0.059, 0.059, 0.059, 0.059, 0.059, 0.059, 0.059, 0.059, 0.059, 0.059, 0.059, 0.059, 0.059, 0.059, 0.059]\n\n\n\nprint(m.values_b())\n\n[0.037, 0.037, 0.037, 0.037, 0.04, 0.04, 0.04, 0.04, 0.039, 0.039, 0.039, 0.039, 0.039, 0.039, 0.039, 0.039, 0.038, 0.038, 0.038, 0.038, 0.035, 0.035, 0.035, 0.035, 0.037, 0.037, 0.037, 0.037, 0.038, 0.038, 0.038, 0.038, 0.039, 0.039, 0.039, 0.039, 0.039, 0.039, 0.039, 0.039, 0.04, 0.04, 0.04, 0.04, 0.039, 0.039, 0.039, 0.039, 0.037, 0.037, 0.037, 0.037, 0.038, 0.038, 0.038, 0.038, 0.037, 0.037, 0.037, 0.037, 0.038, 0.038, 0.038, 0.038, 0.037, 0.037, 0.037, 0.037, 0.038, 0.038, 0.038, 0.038, 0.04, 0.04, 0.04, 0.04, 0.04, 0.04, 0.04, 0.04, 0.042, 0.042, 0.042, 0.042, 0.039, 0.039, 0.039, 0.039, 0.04, 0.04, 0.04, 0.04, 0.043, 0.043, 0.043, 0.043, 0.04, 0.04, 0.04, 0.04, 0.04, 0.04, 0.04, 0.04, 0.042, 0.042, 0.042, 0.042, 0.039, 0.039, 0.039, 0.039, 0.04, 0.04, 0.04, 0.04, 0.038, 0.038, 0.038, 0.038, 0.038, 0.038, 0.038, 0.038, 0.038, 0.038, 0.038, 0.038, 0.038, 0.038, 0.038, 0.038, 0.039, 0.039, 0.039, 0.039, 0.04, 0.04, 0.04, 0.04, 0.039, 0.039, 0.039, 0.039, 0.039, 0.039, 0.039, 0.039, 0.04, 0.04, 0.04, 0.04, 0.04, 0.04, 0.04, 0.04, 0.04, 0.04, 0.04, 0.04, 0.039, 0.039, 0.039, 0.039, 0.038, 0.038, 0.038, 0.038, 0.039, 0.039, 0.039, 0.039, 0.039, 0.039, 0.039, 0.039, 0.039, 0.039, 0.039, 0.039, 0.037, 0.037, 0.037, 0.037, 0.038, 0.038, 0.038, 0.038, 0.038, 0.038, 0.038, 0.038, 0.035, 0.035, 0.035, 0.035, 0.034, 0.034, 0.034, 0.034, 0.034, 0.034, 0.034, 0.034, 0.038, 0.038, 0.038, 0.038, 0.037, 0.037, 0.037, 0.037, 0.037, 0.037, 0.037, 0.037, 0.037, 0.037, 0.037, 0.037, 0.038, 0.038, 0.038, 0.038, 0.038, 0.038, 0.038, 0.038, 0.037, 0.037, 0.037, 0.037, 0.038, 0.038, 0.038, 0.038, 0.039, 0.039, 0.039, 0.039, 0.037, 0.037, 0.037, 0.037, 0.034, 0.034, 0.034, 0.034, 0.033, 0.033, 0.033, 0.033, 0.033, 0.033, 0.033, 0.033, 0.033, 0.033, 0.033, 0.033, 0.034, 0.034, 0.034, 0.034, 0.034, 0.034, 0.034, 0.034, 0.035, 0.035, 0.035, 0.035, 0.035, 0.035, 0.035, 0.035, 0.035, 0.035, 0.035, 0.035, 0.033, 0.033, 0.033, 0.033, 0.035, 0.035, 0.035, 0.035, 0.037, 0.037, 0.037, 0.037, 0.037, 0.037, 0.037, 0.037, 0.037, 0.037, 0.037, 0.037, 0.035, 0.035, 0.035, 0.035, 0.037, 0.037, 0.037, 0.037, 0.035, 0.035, 0.035, 0.035, 0.034, 0.034, 0.034, 0.034, 0.034, 0.034, 0.034, 0.034, 0.035, 0.035, 0.035, 0.035, 0.035, 0.035, 0.035, 0.035, 0.033, 0.033, 0.033, 0.033, 0.033, 0.033, 0.033, 0.033, 0.034, 0.034, 0.034, 0.034, 0.033, 0.033, 0.033, 0.033, 0.032, 0.032, 0.032, 0.032, 0.032, 0.032, 0.032, 0.032, 0.032, 0.032, 0.032, 0.032, 0.032, 0.032, 0.032, 0.032, 0.032, 0.032, 0.032, 0.032, 0.032, 0.032, 0.032, 0.032, 0.034, 0.034, 0.034, 0.034, 0.033, 0.033, 0.033, 0.033, 0.033, 0.033, 0.033, 0.033, 0.031, 0.031, 0.031, 0.031, 0.031, 0.031, 0.031, 0.031, 0.028, 0.028, 0.028, 0.028, 0.029, 0.029, 0.029, 0.029, 0.031, 0.031, 0.031, 0.031, 0.029, 0.029, 0.029, 0.029, 0.031, 0.031, 0.031, 0.031, 0.031, 0.031, 0.031, 0.031, 0.031, 0.031, 0.031, 0.031, 0.032, 0.032, 0.032, 0.032, 0.031, 0.031, 0.031, 0.031, 0.031, 0.031, 0.031, 0.031, 0.031, 0.031, 0.031, 0.031, 0.032, 0.032, 0.032, 0.032, 0.033, 0.033, 0.033, 0.033, 0.033, 0.033, 0.033, 0.033, 0.032, 0.032, 0.032, 0.032, 0.033, 0.033, 0.033, 0.033, 0.034, 0.034, 0.034, 0.034, 0.034, 0.034, 0.034, 0.034, 0.034, 0.034, 0.034, 0.034, 0.035, 0.035, 0.035, 0.035, 0.037, 0.037, 0.037, 0.037, 0.035, 0.035, 0.035, 0.035, 0.034, 0.034, 0.034, 0.034, 0.035, 0.035, 0.035, 0.035, 0.04, 0.04, 0.04, 0.04, 0.04, 0.04, 0.04, 0.04, 0.039, 0.039, 0.039, 0.039, 0.04, 0.04, 0.04, 0.04, 0.043, 0.043, 0.043, 0.043, 0.043, 0.043, 0.043, 0.043, 0.043, 0.043, 0.043, 0.043, 0.042, 0.042, 0.042, 0.042, 0.039, 0.039, 0.039, 0.039, 0.035, 0.035, 0.035, 0.035, 0.031, 0.031, 0.031, 0.031, 0.024, 0.024, 0.024, 0.024, 0.022, 0.022, 0.022, 0.022, 0.02, 0.02, 0.02, 0.02, 0.017, 0.017, 0.017, 0.017, 0.011, 0.011, 0.011, 0.011, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.009, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.011, 0.011, 0.011, 0.011, 0.012, 0.012, 0.012, 0.012, 0.009, 0.009, 0.009, 0.009, 0.011, 0.011, 0.011, 0.011, 0.013, 0.013, 0.013, 0.013, 0.012, 0.012, 0.012, 0.012, 0.016, 0.016, 0.016, 0.016, 0.018, 0.018, 0.018, 0.018, 0.018, 0.018, 0.018, 0.018, 0.022, 0.022, 0.022, 0.022, 0.028, 0.028, 0.028, 0.028, 0.031, 0.031, 0.031, 0.031, 0.028, 0.028, 0.028, 0.028, 0.027, 0.027, 0.027, 0.027, 0.027, 0.027, 0.027, 0.027, 0.028, 0.028, 0.028, 0.028, 0.027, 0.027, 0.027, 0.027, 0.028, 0.028, 0.028, 0.028, 0.026, 0.026, 0.026, 0.026, 0.026, 0.026, 0.026, 0.026, 0.027, 0.027, 0.027, 0.027, 0.024, 0.024, 0.024, 0.024, 0.023, 0.023, 0.023, 0.023, 0.023, 0.023, 0.023, 0.023, 0.021, 0.021, 0.021, 0.021, 0.022, 0.022, 0.022, 0.022, 0.022, 0.022, 0.022, 0.022, 0.023, 0.023, 0.023, 0.023, 0.022, 0.022, 0.022, 0.022, 0.022, 0.022, 0.022, 0.022, 0.021, 0.021, 0.021, 0.021, 0.023, 0.023, 0.023, 0.023, 0.023, 0.023, 0.023, 0.023, 0.026, 0.026, 0.026, 0.026, 0.028, 0.028, 0.028, 0.028, 0.026, 0.026, 0.026, 0.026, 0.026, 0.026, 0.026, 0.026, 0.026, 0.026, 0.026, 0.026, 0.026, 0.026, 0.026, 0.026, 0.027, 0.027, 0.027, 0.027, 0.033, 0.033, 0.033, 0.033, 0.043, 0.043, 0.043, 0.043, 0.057, 0.057, 0.057, 0.057, 0.076, 0.076, 0.076, 0.076, 0.099, 0.099, 0.099, 0.099, 0.131, 0.131, 0.131, 0.131, 0.145, 0.145, 0.145, 0.145, 0.155, 0.155, 0.155, 0.155, 0.162, 0.162, 0.162, 0.162, 0.157, 0.157, 0.157, 0.157, 0.115, 0.115, 0.115, 0.115, 0.033, 0.033, 0.033, 0.033, -0.122, -0.122, -0.122, -0.122, -0.303, -0.303, -0.303, -0.303, -0.553, -0.553, -0.553, -0.553, -0.85, -0.85, -0.85, -0.85, -1.095, -1.095, -1.095, -1.095, -1.286, -1.286, -1.286, -1.286, -1.428, -1.428, -1.428, -1.428, -1.496, -1.496, -1.496, -1.496, -1.433, -1.433, -1.433, -1.433, -1.287, -1.287, -1.287, -1.287, -1.155, -1.155, -1.155, -1.155, -0.973, -0.973, -0.973, -0.973, -0.774, -0.774, -0.774, -0.774, -0.51, -0.51, -0.51, -0.51, -0.261, -0.261, -0.261, -0.261, -0.125, -0.125, -0.125, -0.125, -0.066, -0.066, -0.066, -0.066, -0.038, -0.038, -0.038, -0.038, -0.02, -0.02, -0.02, -0.02, -0.004, -0.004, -0.004, -0.004, 0.01, 0.01, 0.01, 0.01, 0.017, 0.017, 0.017, 0.017, 0.026, 0.026, 0.026, 0.026, 0.033, 0.033, 0.033, 0.033, 0.039, 0.039, 0.039, 0.039, 0.048, 0.048, 0.048, 0.048, 0.054, 0.054, 0.054, 0.054, 0.06, 0.06, 0.06, 0.06, 0.065, 0.065, 0.065, 0.065, 0.068, 0.068, 0.068, 0.068, 0.072, 0.072, 0.072, 0.072, 0.074, 0.074, 0.074, 0.074, 0.076, 0.076, 0.076, 0.076, 0.077, 0.077, 0.077, 0.077, 0.079, 0.079, 0.079, 0.079, 0.082, 0.082, 0.082, 0.082, 0.083, 0.083, 0.083, 0.083, 0.084, 0.084, 0.084, 0.084, 0.084, 0.084, 0.084, 0.084, 0.087, 0.087, 0.087, 0.087, 0.088, 0.088, 0.088, 0.088, 0.087, 0.087, 0.087, 0.087, 0.085, 0.085, 0.085, 0.085, 0.087, 0.087, 0.087, 0.087, 0.088, 0.088, 0.088, 0.088, 0.089, 0.089, 0.089, 0.089, 0.089, 0.089, 0.089, 0.089, 0.089, 0.089, 0.089, 0.089, 0.092, 0.092, 0.092, 0.092, 0.089, 0.089, 0.089, 0.089, 0.088, 0.088, 0.088, 0.088, 0.087, 0.087, 0.087, 0.087, 0.089, 0.089, 0.089, 0.089, 0.089, 0.089, 0.089, 0.089, 0.089, 0.089, 0.089, 0.089, 0.089, 0.089, 0.089, 0.089, 0.09, 0.09, 0.09, 0.09]\n\n\nThe returned pyattimo.Motif has a plot method that shows the motif subsequences, their z-normalized versions, and the positions of the motif in the original time series.\nFinally, and perhaps most importantly for the interactive exploration of time series, the Motif object allows you to plot it.\n\nm.plot()\n\n\n\n\nPlot of the top motif in the dataset, with the positions in the original series highlighted (top plot), the plot of the original subsequences overlaid on top of each other (middle), and the plot of the overlay of their z-normalized version.\n\n\n\n\nGiven that the MotifsIterator object is, well, an iterator, you can easily ask for the next motif:\n\n%time m = next(motifs)\nm.plot()\n\nCPU times: user 7 µs, sys: 1 µs, total: 8 µs\nWall time: 11.9 µs\n\n\n\n\n\nThe second motif in the dataset.\n\n\n\n\nNotice that the time to discover this second motif is much shorter than the time that was required to discover the first one: microseconds instead of seconds. This is a property of the underlying algorithm: for further details we invite you to read the full paper.\nThis explorative process of looking at can be iterated as long as needed, interactively. The motifs are returned by increasing values of distance of their subsequences: as soon as we find a motif whose subsequences are so far away as to no longer be interesting, we can stop the process."
  },
  {
    "objectID": "pyattimo.html#comparison-with-stumpy-and-pyscamp",
    "href": "pyattimo.html#comparison-with-stumpy-and-pyscamp",
    "title": "PyAttimo: scalable time series motifs mining with Python",
    "section": "Comparison with stumpy and pyscamp",
    "text": "Comparison with stumpy and pyscamp\nSo far, we have seen how pyattimo allows to interactively explore motifs. But how does it compare with the state of the art in motif discovery? There is a rich line of work investigating the efficient use of the matrix profile, a data structure that for each subsequence of the input time series holds information about its most similar subsequence.\nIn particular, the stumpy Python package implements a Numba JIT-compiled version of the algorithm presented by Zhu et al. (2016), with a very convenient user interface.\nA very efficient C++ Matrix Profile implementation (with GPU support) is provided by scamp, implementing ideas presented in the paper by Zimmerman et al. (2019). scamp comes with a Python interface, namely pyscamp.\nBoth stumpy and pyscamp support GPU execution, but this notebook has been rendered on a system somewhat computationally limited1. In particular, this system does not support CUDA. Therefore, we will focus on the CPU functionality provided by both packages, and compare attimo with both.1 A 2017 MacBook Pro with a 2.3 GHz Intel Core i5 dual core processor, with 8GB of RAM memory.\nWe consider the ECG dataset we already introduced above, with 1,000,000 data points. As a benchmark, we will measure the running time of both stumpy, pyscamp, and attimo on prefixes of increasing size of the time series. For attimo, we extract from the iterator only the first motif.\nBeware that stumpy and pyscamp compute the full matrix profile, which contains a lot more information than just the top motif. The point of this (rather unscientific) benchmark is to get a sense of the gains we can make if we focus on just finding the top motif.Later we shall see how many motifs we can find before the fastest of the baselines completes.\nThe plot below reports the results of this experiment (you can expand the code to see how the experiments have been run).\n\n\nCode\nimport sqlite3\nimport time \nimport stumpy\nimport pyscamp\nimport pandas as pd\nimport seaborn as sns\nimport numpy as np\n\nw = 1000\n\n# force numba precompilation\nstumpy.stump(ts[:2*w], m=w)\n\n# We persist results in a sqlite database, so to avoid rerunning experiments unnecessarily\ndef already_run(db, algorithm, prefix):\n    return db.execute(\n        \"SELECT * FROM experiments WHERE algorithm = ? AND prefix = ?\", \n        [algorithm, prefix]).fetchone() is not None\n\nwith sqlite3.connect(\".quarto/experiments.db\") as db:\n    db.execute(\"CREATE TABLE IF NOT EXISTS experiments (algorithm TEXT, prefix INT, time_s REAL)\")\n\n    prefixes = [10000, 25000, 30000, 50000, 75000, 100000, 250000, 500000, 1000000]\n\n    timeout = 20\n\n    for prefix in prefixes:\n        # the prefix on which to benchmark\n        data = ts[:prefix]\n\n        if prefix <= 250000 and not already_run(db, \"stumpy\", prefix):\n            start = time.time()\n            stumpy.stump(data, m=w)\n            end = time.time()\n            db.execute(\"INSERT INTO experiments VALUES (?, ?, ?)\", [\"stumpy\", prefix, end - start])\n\n        if prefix <= 500000 and not already_run(db, \"pyscamp\", prefix):\n            start = time.time()\n            pyscamp.selfjoin(data, w)\n            end = time.time()\n            db.execute(\"INSERT INTO experiments VALUES (?, ?, ?)\", [\"pyscamp\", prefix, end - start])\n\n        if not already_run(db, \"attimo\", prefix):\n            start = time.time()\n            motifs_iter = pyattimo.MotifsIterator(data, w=w, max_k=1, repetitions=50, delta=0.01)\n            next(motifs_iter)\n            end = time.time()\n            db.execute(\"INSERT INTO experiments VALUES (?, ?, ?)\", [\"attimo\", prefix, end - start])\n\n    results = pd.read_sql(\"SELECT prefix, algorithm, time_s FROM experiments ORDER BY prefix, algorithm\", db)\n\ncolors = sns.color_palette()\npalette = {\n    \"attimo\": colors[0],\n    \"pyscamp\": colors[1],\n    \"stumpy\": colors[2]\n}\nax = sns.lineplot(\n    data = results,\n    x = \"prefix\",\n    y = \"time_s\",\n    hue = \"algorithm\",\n    palette = palette\n)\n\n# Polynomial (2nd degree) regression to fill in times for larger prefixes\nfits = {}\nfor algorithm in [\"pyscamp\"]:\n    fitdat = results[results[\"algorithm\"] == algorithm]\n    fits[algorithm] = np.poly1d(np.polyfit(fitdat[\"prefix\"], fitdat[\"time_s\"], 2))\n    xs = np.linspace(fitdat[\"prefix\"].max(), prefixes[-1])\n    ax.plot(xs, fits[algorithm](xs), '--', color=palette[algorithm])\n\nplt.show()\n\n\n\n\n\nRuntime comparison on time series of different lengths to find the top motif. Dashed lines are for estimated runtimes.\n\n\n\n\nThe expected behavior of both pyscamp and stumpy is to require time \\(O(n^2)\\), where \\(n\\) is the length of the time series. Indeed, from the plot we can infer that this is the actual behavior in this experiment: doubling the time series length quadruples the running time.\nAs for attimo, note that the running time to find the top motif is much shorter: the following table reports the same times (in seconds) that are shown in the above plot\n\n\n\n\n\nprefix\nattimo\npyscamp\nstumpy\n\n\n\n\n10000\n0.20\n0.07\n0.28\n\n\n25000\n0.38\n0.29\n1.90\n\n\n30000\n0.50\n0.38\n2.10\n\n\n50000\n0.74\n0.95\n6.32\n\n\n75000\n4.81\n2.56\n20.76\n\n\n100000\n1.46\n3.88\n40.62\n\n\n250000\n3.47\n26.09\n255.20\n\n\n500000\n5.56\n83.76\nnan\n\n\n1000000\n18.84\nnan\nnan\n\n\n\n\n\nAs said above, both pyscamp and stumpy return the full matrix profile, which contains more information than just the top motif. Indeed, it can be used to retrieve the other motifs (albeit with some caveats). To take into account this, rather than fixing a-priori an arbitrary number of motifs to look for, we fix as a time budget the time employed by the fastest baseline, pyscamp, on one million data points. Given that budget, we traverse the motif iterator provided by attimo until the time budget is exhausted, counting how many motifs we are able to discover. This procedure is implemented by the following snippet.\n\ndef enumerate_with_budget(motifs_iterator, budget):\n    start = time.time()\n    times = []\n    motifs = []\n    cnt = 0\n    elapsed = 0\n    while elapsed <= budget:\n        try:\n            m = next(motifs_iterator)\n            cnt += 1\n            elapsed = time.time() - start \n            times.append(elapsed)\n            motifs.append(m)\n        except StopIteration:\n            return cnt, times, motifs\n    return cnt, times, motifs\n\nThe following code runs the experiment, using as a budged the \\(\\approx 300\\) seconds employed by pyscamp.\n\nimport os\nfname = \".discover.parquet\"\nif not os.path.isfile(fname):\n    start = time.time() \n    motifs = pyattimo.MotifsIterator(ts, w=1000, max_k=300, repetitions=50, delta=0.01)\n    end = time.time()\n    index_time = end - start\n    time_budget = fits[\"pyscamp\"](len(ts))\n    cnt, elapsed_times, motifs_list = enumerate_with_budget(motifs, time_budget - index_time)\n    print(\"Motifs found in {:.2f} seconds: {}\".format(time_budget, cnt))\n\n    elapsed_times = pd.DataFrame({\n        'elapsed_time_s': elapsed_times,\n        'motif_distance': [m.distance for m in motifs_list],\n        'motif_rank': np.arange(len(elapsed_times))\n    })\n    elapsed_times.to_parquet(fname)\nelse:\n    elapsed_times = pd.read_parquet(fname)\n\nUsing attimo, we can iterate through 200 motifs before pyscamp is done computing the matrix profile!\nThe plot below, reports on the \\(x\\) axis the rank of each motif found, while the \\(y\\) axis reports the time elapsed since the creation of the MotifIterator object and the discovery of each motif. In other words, the leftmost point is the time required taken to discover the first motif.\n\n\n\n\n\n\n\n\n\nYou can see that the first \\(\\approx\\) 200 motifs are found rather fast, while the last motifs require to invest more computation time. The reason is that the distance of the subsequences making up the lower-ranked motifs is larger than the distance of the top motifs, thus forcing the algorithm to spend more time confirming them.\nGiven the above experiment, it is clear why using pyattimo can be advantageous in an interactive setting: the user can stop the computation whenever they find it most convenient."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Attimo: fast time series motif mining",
    "section": "",
    "text": "Intuitively, a motif is a subsequence in a time series that has at least one similar occurrence in another location of the same time series. More formally, for a fixed subsequence length \\(w\\) and for a given distance function between subsequences of length \\(m\\) of a time series, we can define the top motif as being the pair of subsequences at minimum distance. Since subsequences can overlap, usually overlapping subsequences are ignored1.\n\n\n\n\nFootnotes\n\n\nThis definition of subsequences to be ignored is somewhat flexible. For instance, we can allow for overlaps of at most \\(w/4\\), or \\(w/2\\)↩︎"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  }
]